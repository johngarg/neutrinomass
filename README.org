* Exploding operators for Majorana neutrino masses and beyond ðŸ’£ðŸ’¥

This is the code accompanying the paper "Exploding operators for Majorana
neutrino masses and beyond" (arXiv:2008.xxxxx).

The code is split into three smaller modules:

1. =tensormethod= provides the field objects and effective operators.
2. =completions= takes the effective operators generated by =tensormethod= and
   finds their tree-level UV completions with the methods discussed in the
   paper.
3. =analysis= contains scripts and notebooks analysing various aspects of the
   models contained in the database. There are examples there of how to query
   the models in the database.
4. =database= The database of lepton-number violating models and functions for
   interacting with it.
5. =matching= The code we use to match the models onto the complete basis of
   operators at dimension 7.

Each module is described in detail below.

#+BEGIN_SRC bash
.
â”œâ”€â”€ __init__.py
â”œâ”€â”€ analysis
â”‚Â Â  â”œâ”€â”€ IBP_and_EOM.ipynb
â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”œâ”€â”€ closures.ipynb
â”‚Â Â  â”œâ”€â”€ dimension_six_smeft_example.ipynb
â”‚Â Â  â””â”€â”€ topologies.ipynb
â”œâ”€â”€ completions
â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”œâ”€â”€ completions.py
â”‚Â Â  â”œâ”€â”€ completions_test.py
â”‚Â Â  â”œâ”€â”€ core.py
â”‚Â Â  â”œâ”€â”€ core_test.py
â”‚Â Â  â”œâ”€â”€ d9.py
â”‚Â Â  â”œâ”€â”€ deriv_operators.p
â”‚Â Â  â”œâ”€â”€ generatetopologies
â”‚Â Â  â”œâ”€â”€ operators.p
â”‚Â Â  â”œâ”€â”€ operators.py
â”‚Â Â  â”œâ”€â”€ operators_nf1.p
â”‚Â Â  â”œâ”€â”€ operators_test.py
â”‚Â Â  â”œâ”€â”€ tikzfeynman.py
â”‚Â Â  â”œâ”€â”€ topologies.py
â”‚Â Â  â”œâ”€â”€ topology_data
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ deletedata
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ diagrams
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ graphs
â”‚Â Â  â”‚Â Â  â””â”€â”€ partitions
â”‚Â Â  â”œâ”€â”€ utils.py
â”‚Â Â  â””â”€â”€ wolfram
â”‚Â Â      â””â”€â”€ generatetopologies.wl
â”œâ”€â”€ database
â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”œâ”€â”€ closures.py
â”‚Â Â  â”œâ”€â”€ closures_test.py
â”‚Â Â  â”œâ”€â”€ database.dat
â”‚Â Â  â”œâ”€â”€ database.py
â”‚Â Â  â”œâ”€â”€ export.py
â”‚Â Â  â”œâ”€â”€ export_test.py
â”‚Â Â  â”œâ”€â”€ json_serialiser.py
â”‚Â Â  â”œâ”€â”€ operators.py
â”‚Â Â  â””â”€â”€ utils.py
â”œâ”€â”€ tensormethod
â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”œâ”€â”€ contract.py
â”‚Â Â  â”œâ”€â”€ contract_test.py
â”‚Â Â  â”œâ”€â”€ core.py
â”‚Â Â  â”œâ”€â”€ core_test.py
â”‚Â Â  â”œâ”€â”€ deriv_operators.p
â”‚Â Â  â”œâ”€â”€ deriv_operators.py
â”‚Â Â  â”œâ”€â”€ hs.py
â”‚Â Â  â”œâ”€â”€ hs_test.py
â”‚Â Â  â”œâ”€â”€ lagrangian.py
â”‚Â Â  â”œâ”€â”€ lagrangian_test.py
â”‚Â Â  â”œâ”€â”€ latexoperators
â”‚Â Â  â”œâ”€â”€ lnv.py
â”‚Â Â  â”œâ”€â”€ lnvderivlatex
â”‚Â Â  â”œâ”€â”€ lnvlatex
â”‚Â Â  â”œâ”€â”€ operatorxcheck.py
â”‚Â Â  â”œâ”€â”€ output.p
â”‚Â Â  â”œâ”€â”€ parse_hs.py
â”‚Â Â  â”œâ”€â”€ sm.py
â”‚Â Â  â”œâ”€â”€ smeft.py
â”‚Â Â  â””â”€â”€ utils.py
â””â”€â”€ utils
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ functions.py
    â””â”€â”€ match.py
#+END_SRC

** =tensormethod=

This module adapts the =sympy= tensor and tensor index objects for the special
case of SU(N) tensors representing fields transforming under the SM gauge group.
(Since =sympy= version 1.3, the constructors of these objects have been made
more user-friendly. The code here uses =sympy= version 1.2 but I plan on
upgrading to the latest version of =sympy= soon.) Fields carry a label string as
well as dynkin digits which define the irreducible representation. For example
#+BEGIN_SRC python
>>> from sympy import Rational
>>> from neutrinomass.tensormethod import Field
>>> H = Field("H", "00001", charges={"y": Rational("1/2")})
>>> Q = Field("H", "10101", charges={"y": Rational("1/6"), "3b": 1})
#+END_SRC
represent an isodoublet scalar (the Higgs) and left-chiral fermion transforming
in the fundamental of SU(3) and SU(2) (the left-handed quark doublet). The
charges dictionary may in principle contain many U(1)s but hypercharge must be
one (initialised to 0). Fields can be called on appropriately labelled indices.
The indices can be passed in as strings according to the following rules:
- The first character in the string is a minus sign for lowered indices
- Apart from a minus sign, the first character in the string must be one u, d,
  c, i standing for undotted, dotted, colour and isospin.
- The next element in the string is an identifier.

Contracted indices have a special representation (inherited from the =sympy=
objects). You can do basic tensor algebra, and make operators from products of
fields:
#+BEGIN_SRC python
>>> from neutrinomass.tensormethod import eps
>>> h = H("i0")
>>> h
H(i0)
>>> q = Q("u0 c0 i1")
>>> q
Q(u0, c0, i1)
>>> h * q * eps("-i0 -i1")
H(I_0)*Q(u0, c0, I_1)*Eps(-I_0, -I_1)
>>> (h * q * eps("-i0 -i1")).dynkin
10100
#+END_SRC
=tensormethod= also knows about Bose-Einstein and Fermi-Dirac statistics.

Invariants can be constructed explicitly, with certain indices optionally
ignored (as we want in our case)
#+BEGIN_SRC python
>>> from neutrinomass.tensormethod import L, H, invariants
>>> invariants(L, L, H, H)
[L(U_0, I_0)*L(U_1, I_1)*Eps(-U_1, -U_0)*H(I_2)*Eps(-I_0, -I_2)*H(I_3)*Eps(-I_3, -I_1)]
>>> o1 = invariants(L, L, H, H, ignore=["u"])
>>> o1
[L(u0, I_0)*L(u1, I_1)*H(I_2)*Eps(-I_0, -I_2)*H(I_3)*Eps(-I_3, -I_1)]
>>> o1.latex()
'L^{i} L^{j} H^{k} H^{l} \\epsilon_{i k} \\epsilon_{j l}'
#+END_SRC
Currently algorithms removing operators equivalent up to certain kinds of index
relabellings are implemented only for the contraction of one index type at a
time.

The module also contains results from the Hilbert Series up to dimension-11 in
the Î”L = 2 SMEFT.

** =completions=

The completions module contains the functionality for finding the tree-level
completions of =EffectiveOperator= objects. These are constructed from
=tensormethod.operator= objects very simply:
#+BEGIN_SRC python
>>> from neutrinomass.tensormethod import L, H, invariants
>>> from neutrinomass.completions import EffectiveOperator, operator_completions, collect_models
>>> o1 = invariants(L, L, H, H, ignore=["u"])
>>> o1
[L(u0, I_0)*L(u1, I_1)*H(I_2)*Eps(-I_0, -I_2)*H(I_3)*Eps(-I_3, -I_1)]
>>> eff_o1 = EffectiveOperator("O_1", o1)
#+END_SRC
Models generating the Weinberg at tree-level can then be found with the
=operator_completions= and =collect_models= functions
#+BEGIN_SRC python
>>> seesaw_1, seesaw_2, seesaw_3 = collect_models(operator_completions(eff_o1))
#+END_SRC
The =Model= objects are collections of =Completion= objects that contain the
same particle content. Each =Completion= object has an associated =Lagrangian=,
which contains information about the lepton-number violating interaction terms,
and can be called upon to generate the entire gauge and Lorentz invariant
renormalisable Lagrangian:
#+BEGIN_SRC python
>>> lag = seesaw_2.lagrangian; lag
>>> lag.generate_all_terms(); lag
#+END_SRC

The completions are found by filling in allowed topologies generated with
=FeynArts= through Mathematica. Relatively recently an [[https://reference.wolfram.com/language/WolframClientForPython/][nice Python interface to
Mathematica]] was released, which would make this bridge much nicer. Many
topologies are already loaded in. Generation of new topologies happens with the
=generate_topologies= script.
