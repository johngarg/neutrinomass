* Example code for generating tree-level completions of LNV effective operators

This is the code accompanying the paper "Exploding operators for Majorana
neutrino mass" (arXiv:1912.xxxxx).

The code is split into three smaller modules:

1. =tensormethod= provides the field objects and effective operators.
2. =completions= takes the effective operators generated by =tensormethod= and
   finds their tree-level UV completions with the methods discussed in the
   paper.
3. =analysis= contains scripts and notebooks analysing various aspects of the
   models contained in the database. There are examples there of how to query
   the models in the database.

Each module is described in detail below.

** =tensormethod=

This module adapts the =sympy= tensor and tensor index objects for the special
case of SU(N) tensors representing fields transforming under the SM gauge group.
Fields carry a label string as well as dynkin digits which define the
irreducible representation. For example,
#+BEGIN_SRC python
>>> from sympy import Rational
>>> from mv.tensormethod import Field
>>> H = Field("H", "00001", charges={"y": Rational("1/2")})
>>> Q = Field("H", "10101", charges={"y": Rational("1/6"), "3b": 1})
#+END_SRC
represent an isodoublet scalar (the Higgs) and left-chiral fermion transforming
in the fundamental of SU(3) and SU(2) (the left-handed quark doublet). The
charges dictionary may in principle contain many U(1)s but hypercharge must be
one (initialised to 0). Fields can be called on appropriately labelled indices.
The indices can be passed in a strings according to the following rules:
- The first character in the string is a minus sign for lowered indices
- Apart from a minus sign, the first character in the string must be one u, d,
  c, i standing for undotted, dotted, colour and isospin.
- The next element in the string is an integer identifier.

Contracted indices have a special representation. You can do basic tensor
algebra, and make operators from products of fields:
#+BEGIN_SRC python
>>> from mv.tensormethod import eps
>>> h = H("i0")
>>> h
H(i0)
>>> q = Q("u0 c0 i1")
>>> q
Q(u0, c0, i1)
>>> h * q * eps("-i0 -i1")
H(I_0)*Q(u0, c0, I_1)*Eps(-I_0, -I_1)
>>> (h * q * eps("-i0 -i1")).dynkin
10100
#+END_SRC
=tensormethod= also knows about Bose-Einstein and Fermi-Dirac statistics.

Invariants can be constructed explicitely, with certain indices optionally ignored
#+BEGIN_SRC python
>>> from mv.tensormethod import L, H, invariants
>>> invariants(L, L, H, H)
[L(U_0, I_0)*L(U_1, I_1)*Eps(-U_1, -U_0)*H(I_2)*Eps(-I_0, -I_2)*H(I_3)*Eps(-I_3, -I_1)]
>>> o1 = invariants(L, L, H, H, ignore=["u"])
>>> o1
[L(u0, I_0)*L(u1, I_1)*H(I_2)*Eps(-I_0, -I_2)*H(I_3)*Eps(-I_3, -I_1)]
>>> o1.latex()
'L^{i} L^{j} H^{k} H^{l} \\epsilon_{i k} \\epsilon_{j l}'
#+END_SRC
Currently algorithms removing operators equivalent up to certain kinds of index
relabellings are implemented only for the contraction of one index type at a
time.

The module also contains results from the Hilbert Series up to dimension-11 in
the Î”L = 2 SMEFT.

** =completions=
